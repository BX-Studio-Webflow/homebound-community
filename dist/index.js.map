{
  "version": 3,
  "sources": ["../bin/live-reload.js", "../src/utils/sticky-nav.ts", "../src/index.ts"],
  "sourcesContent": ["new EventSource(`${SERVE_ORIGIN}/esbuild`).addEventListener('change', () => location.reload());\r\n", "/**\r\n * Sticky navigation controller\r\n * Handles scroll-based active link highlighting and click/tap navigation\r\n */\r\n\r\nexport class StickyNavController {\r\n  private links: Element[] = [];\r\n  private observer: IntersectionObserver | null = null;\r\n  private visibleSections: Set<string> = new Set();\r\n\r\n  /**\r\n   * Maps dev-target attribute values to their corresponding section IDs.\r\n   * Handles spelling mismatches between the nav markup and section IDs.\r\n   */\r\n  private readonly sectionMap: Record<string, string> = {\r\n    overview: 'overview-section',\r\n    'floor-plans': 'floor-plans-section',\r\n    amentities: 'amentities-section',\r\n    personalisation: 'personalization-section',\r\n    'browse-homes': 'lots-section',\r\n    process: 'process-section',\r\n  };\r\n\r\n  /**\r\n   * Ordered list of dev-target values matching the top-to-bottom page section order.\r\n   * Used to determine which section is \"topmost\" when multiple are visible at once.\r\n   */\r\n  private readonly sectionOrder: string[] = [\r\n    'overview',\r\n    'floor-plans',\r\n    'amentities',\r\n    'personalisation',\r\n    'browse-homes',\r\n  ];\r\n\r\n  init(): void {\r\n    this.links = Array.from(document.querySelectorAll('.tab-links[dev-target]'));\r\n\r\n    if (!this.links.length) {\r\n      console.error('StickyNavController: No tab links found.');\r\n      return;\r\n    }\r\n\r\n    this.setupClickHandlers();\r\n    this.setupScrollObserver();\r\n\r\n    // On first load, scroll the strip to the link already marked is-active in the\r\n    // HTML (Webflow sets this). rAF defers until layout is painted so offsetLeft\r\n    // values are accurate.\r\n    requestAnimationFrame(() => {\r\n      const initialActive =\r\n        (this.links.find((l) => l.classList.contains('is-active')) as HTMLElement | undefined) ??\r\n        (this.links[0] as HTMLElement | undefined);\r\n\r\n      if (initialActive) {\r\n        initialActive.classList.add('is-active');\r\n        this.scrollLinkIntoStrip(initialActive);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Smooth-scroll to the target section on click/tap.\r\n   * Offsets the scroll position by the sticky nav height so the section\r\n   * heading isn't hidden behind the bar.\r\n   */\r\n  private setupClickHandlers(): void {\r\n    this.links.forEach((link) => {\r\n      link.addEventListener('click', (e) => {\r\n        e.preventDefault();\r\n\r\n        const target = link.getAttribute('dev-target');\r\n        if (!target) return;\r\n\r\n        const sectionId = this.sectionMap[target];\r\n        if (!sectionId) return;\r\n\r\n        const section = document.getElementById(sectionId);\r\n        if (!section) {\r\n          console.error(`StickyNavController: Section #${sectionId} not found.`);\r\n          return;\r\n        }\r\n\r\n        const navBar = link.closest('.tab-header') as HTMLElement | null;\r\n        const navHeight = navBar ? navBar.offsetHeight : 0;\r\n\r\n        const sectionTop = section.getBoundingClientRect().top + window.scrollY - navHeight;\r\n\r\n        window.scrollTo({ top: sectionTop, behavior: 'smooth' });\r\n\r\n        // Set active immediately so the UI responds at the tap/click moment\r\n        this.setActiveLink(target);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Use IntersectionObserver to keep the active link in sync with scroll position.\r\n   *\r\n   * rootMargin '-10% 0px -85% 0px' shrinks the observable viewport to a band near\r\n   * the top of the screen (roughly the top 15%, offset slightly for the sticky bar).\r\n   * A section \"intersects\" when its top edge enters that band, which is the natural\r\n   * moment a reader considers themselves to be inside that section.\r\n   *\r\n   * Among all currently intersecting sections, the one that appears earliest in\r\n   * sectionOrder wins, so rapidly scrolled or short sections stay consistent.\r\n   */\r\n  private setupScrollObserver(): void {\r\n    this.observer = new IntersectionObserver(\r\n      (entries) => {\r\n        entries.forEach((entry) => {\r\n          const devTarget = this.getDevTargetBySectionId(entry.target.id);\r\n          if (!devTarget) return;\r\n\r\n          if (entry.isIntersecting) {\r\n            this.visibleSections.add(devTarget);\r\n          } else {\r\n            this.visibleSections.delete(devTarget);\r\n          }\r\n        });\r\n\r\n        const activeTarget = this.sectionOrder.find((t) => this.visibleSections.has(t));\r\n        if (activeTarget) {\r\n          this.setActiveLink(activeTarget);\r\n        }\r\n      },\r\n      {\r\n        rootMargin: '-10% 0px -85% 0px',\r\n        threshold: 0,\r\n      }\r\n    );\r\n\r\n    this.sectionOrder.forEach((target) => {\r\n      const sectionId = this.sectionMap[target];\r\n      if (!sectionId) return;\r\n      const section = document.getElementById(sectionId);\r\n      if (section) {\r\n        this.observer!.observe(section);\r\n      } else {\r\n        console.error(`StickyNavController: Section #${sectionId} not found in DOM.`);\r\n      }\r\n    });\r\n  }\r\n\r\n  private setActiveLink(targetName: string): void {\r\n    this.links.forEach((link) => {\r\n      const isActive = link.getAttribute('dev-target') === targetName;\r\n      link.classList.toggle('is-active', isActive);\r\n      if (isActive) this.scrollLinkIntoStrip(link as HTMLElement);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * On mobile (\u2264767px), scroll the active link to the centre of the tab-left\r\n   * strip so it is always fully visible without the user needing to swipe.\r\n   */\r\n  private scrollLinkIntoStrip(link: HTMLElement): void {\r\n    if (window.innerWidth > 767) return;\r\n\r\n    const strip = link.closest('[dev-target=\"tab-left\"]') as HTMLElement | null;\r\n    if (!strip) return;\r\n\r\n    const targetScrollLeft = link.offsetLeft - strip.offsetWidth / 2 + link.offsetWidth / 2;\r\n    strip.scrollTo({ left: targetScrollLeft, behavior: 'smooth' });\r\n  }\r\n\r\n  private getDevTargetBySectionId(sectionId: string): string | null {\r\n    return this.sectionOrder.find((key) => this.sectionMap[key] === sectionId) ?? null;\r\n  }\r\n\r\n  destroy(): void {\r\n    this.observer?.disconnect();\r\n    this.observer = null;\r\n    this.visibleSections.clear();\r\n  }\r\n}\r\n", "import { StickyNavController } from '$utils/sticky-nav';\r\n\r\nwindow.Webflow ||= [];\r\nwindow.Webflow.push(() => {\r\n\r\n  const stickyNavController = new StickyNavController();\r\n  stickyNavController.init();\r\n});\r\n"],
  "mappings": "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",
  "names": []
}
